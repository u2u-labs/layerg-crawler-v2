// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: system.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (
    id, chain_id, contract_address, initial_block
) VALUES ($1, $2, $3, $4)
RETURNING id, chain_id, contract_address, created_at, updated_at, initial_block, last_updated
`

type CreateAssetParams struct {
	ID              string        `json:"id"`
	ChainID         int32         `json:"chain_id"`
	ContractAddress string        `json:"contract_address"`
	InitialBlock    sql.NullInt64 `json:"initial_block"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRowContext(ctx, createAsset,
		arg.ID,
		arg.ChainID,
		arg.ContractAddress,
		arg.InitialBlock,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ChainID,
		&i.ContractAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InitialBlock,
		&i.LastUpdated,
	)
	return i, err
}

const createChain = `-- name: CreateChain :one
INSERT INTO chains (
    id, chain, name, rpc_url, chain_id, explorer, latest_block, block_time
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, chain, name, rpc_url, chain_id, explorer, latest_block, block_time
`

type CreateChainParams struct {
	ID          int32  `json:"id"`
	Chain       string `json:"chain"`
	Name        string `json:"name"`
	RpcUrl      string `json:"rpc_url"`
	ChainID     int64  `json:"chain_id"`
	Explorer    string `json:"explorer"`
	LatestBlock int64  `json:"latest_block"`
	BlockTime   int32  `json:"block_time"`
}

func (q *Queries) CreateChain(ctx context.Context, arg CreateChainParams) (Chain, error) {
	row := q.db.QueryRowContext(ctx, createChain,
		arg.ID,
		arg.Chain,
		arg.Name,
		arg.RpcUrl,
		arg.ChainID,
		arg.Explorer,
		arg.LatestBlock,
		arg.BlockTime,
	)
	var i Chain
	err := row.Scan(
		&i.ID,
		&i.Chain,
		&i.Name,
		&i.RpcUrl,
		&i.ChainID,
		&i.Explorer,
		&i.LatestBlock,
		&i.BlockTime,
	)
	return i, err
}

const createOnchainHistory = `-- name: CreateOnchainHistory :one
INSERT INTO onchain_histories (
    "from", "to", chain_id, asset_id, tx_hash, receipt, event_type, timestamp
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, "from", "to", chain_id, asset_id, tx_hash, receipt, event_type, timestamp, created_at, updated_at
`

type CreateOnchainHistoryParams struct {
	From      string          `json:"from"`
	To        string          `json:"to"`
	ChainID   int32           `json:"chain_id"`
	AssetID   string          `json:"asset_id"`
	TxHash    string          `json:"tx_hash"`
	Receipt   json.RawMessage `json:"receipt"`
	EventType sql.NullString  `json:"event_type"`
	Timestamp time.Time       `json:"timestamp"`
}

func (q *Queries) CreateOnchainHistory(ctx context.Context, arg CreateOnchainHistoryParams) (OnchainHistory, error) {
	row := q.db.QueryRowContext(ctx, createOnchainHistory,
		arg.From,
		arg.To,
		arg.ChainID,
		arg.AssetID,
		arg.TxHash,
		arg.Receipt,
		arg.EventType,
		arg.Timestamp,
	)
	var i OnchainHistory
	err := row.Scan(
		&i.ID,
		&i.From,
		&i.To,
		&i.ChainID,
		&i.AssetID,
		&i.TxHash,
		&i.Receipt,
		&i.EventType,
		&i.Timestamp,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllChain = `-- name: GetAllChain :many
SELECT id, chain, name, rpc_url, chain_id, explorer, latest_block, block_time FROM chains
`

func (q *Queries) GetAllChain(ctx context.Context) ([]Chain, error) {
	rows, err := q.db.QueryContext(ctx, getAllChain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chain{}
	for rows.Next() {
		var i Chain
		if err := rows.Scan(
			&i.ID,
			&i.Chain,
			&i.Name,
			&i.RpcUrl,
			&i.ChainID,
			&i.Explorer,
			&i.LatestBlock,
			&i.BlockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetByAddress = `-- name: GetAssetByAddress :one
SELECT id, chain_id, contract_address, created_at, updated_at, initial_block, last_updated FROM assets 
WHERE chain_id = $1 AND contract_address = $2
`

type GetAssetByAddressParams struct {
	ChainID         int32  `json:"chain_id"`
	ContractAddress string `json:"contract_address"`
}

func (q *Queries) GetAssetByAddress(ctx context.Context, arg GetAssetByAddressParams) (Asset, error) {
	row := q.db.QueryRowContext(ctx, getAssetByAddress, arg.ChainID, arg.ContractAddress)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ChainID,
		&i.ContractAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InitialBlock,
		&i.LastUpdated,
	)
	return i, err
}

const getChainById = `-- name: GetChainById :one
SELECT id, chain, name, rpc_url, chain_id, explorer, latest_block, block_time FROM chains WHERE id = $1
`

func (q *Queries) GetChainById(ctx context.Context, id int32) (Chain, error) {
	row := q.db.QueryRowContext(ctx, getChainById, id)
	var i Chain
	err := row.Scan(
		&i.ID,
		&i.Chain,
		&i.Name,
		&i.RpcUrl,
		&i.ChainID,
		&i.Explorer,
		&i.LatestBlock,
		&i.BlockTime,
	)
	return i, err
}

const getOnchainHistoriesByAsset = `-- name: GetOnchainHistoriesByAsset :many
SELECT id, "from", "to", chain_id, asset_id, tx_hash, receipt, event_type, timestamp, created_at, updated_at FROM onchain_histories 
WHERE asset_id = $1 
ORDER BY timestamp DESC 
LIMIT $2
`

type GetOnchainHistoriesByAssetParams struct {
	AssetID string `json:"asset_id"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetOnchainHistoriesByAsset(ctx context.Context, arg GetOnchainHistoriesByAssetParams) ([]OnchainHistory, error) {
	rows, err := q.db.QueryContext(ctx, getOnchainHistoriesByAsset, arg.AssetID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OnchainHistory{}
	for rows.Next() {
		var i OnchainHistory
		if err := rows.Scan(
			&i.ID,
			&i.From,
			&i.To,
			&i.ChainID,
			&i.AssetID,
			&i.TxHash,
			&i.Receipt,
			&i.EventType,
			&i.Timestamp,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedAssetsByChainId = `-- name: GetPaginatedAssetsByChainId :many
SELECT id, chain_id, contract_address, created_at, updated_at, initial_block, last_updated FROM assets 
WHERE chain_id = $1 
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaginatedAssetsByChainIdParams struct {
	ChainID int32 `json:"chain_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetPaginatedAssetsByChainId(ctx context.Context, arg GetPaginatedAssetsByChainIdParams) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, getPaginatedAssetsByChainId, arg.ChainID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Asset{}
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ChainID,
			&i.ContractAddress,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InitialBlock,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChainLatestBlock = `-- name: UpdateChainLatestBlock :exec
UPDATE chains 
SET latest_block = $2 
WHERE id = $1
`

type UpdateChainLatestBlockParams struct {
	ID          int32 `json:"id"`
	LatestBlock int64 `json:"latest_block"`
}

func (q *Queries) UpdateChainLatestBlock(ctx context.Context, arg UpdateChainLatestBlockParams) error {
	_, err := q.db.ExecContext(ctx, updateChainLatestBlock, arg.ID, arg.LatestBlock)
	return err
}
