package generator

import (
	"os"
	"strings"
	"text/template"
)

type EventHandlerConfig struct {
	Kind     string   // e.g., "EthereumHandlerKind.Event"
	Handler  string   // e.g., "HandleTransfer"
	Function string   // e.g., "approve"
	Topics   []string // e.g., ["Transfer(address,address,uint256)"]
}

const eventHandlerTemplate = `
// Code generated - DO NOT EDIT.
// This file is generated by event_handler_generator.go

package eventhandlers

import (
	"context"
	"fmt"
	"math/big"

	"github.com/unicornultrafoundation/go-u2u/common"
	"github.com/unicornultrafoundation/go-u2u/core/types"
	"github.com/unicornultrafoundation/go-u2u/crypto"
	"go.uber.org/zap"
)

// EventHandler defines the interface for handling blockchain events
type EventHandler interface {
	HandleEvent(ctx context.Context, log *types.Log, logger *zap.SugaredLogger) error
}

// DefaultHandler is a basic implementation of EventHandler
type DefaultHandler struct{}

func (h *DefaultHandler) HandleEvent(ctx context.Context, log *types.Log, logger *zap.SugaredLogger) error {
	logger.Infow("Default handler called",
		"signature", log.Topics[0].Hex(),
		"contract", log.Address.Hex(),
		"tx", log.TxHash.Hex(),
	)
	return nil
}

{{range .Events}}
// {{.Name}} represents the event data for {{.Signature}}
type {{.Name}} struct {
	{{range .Params}}
	{{title .Name}} {{.GoType}} // Capitalize field names
	{{end}}
	Raw *types.Log
}

func Unpack{{.Name}}(log *types.Log) (*{{.Name}}, error) {
	event := new({{.Name}})
	event.Raw = log

	{{range $index, $param := .Params}}
	{{if .Indexed}}
	if len(log.Topics) < {{add $index 2}} {
		return nil, fmt.Errorf("missing topic for indexed parameter {{.Name}}")
	}
	{{if eq .Type "address"}}
	event.{{title .Name}} = common.HexToAddress(log.Topics[{{add $index 1}}].Hex())
	{{else if eq .Type "uint256"}}
	event.{{title .Name}} = new(big.Int).SetBytes(log.Topics[{{add $index 1}}].Bytes())
	{{end}}
	{{else}}
	event.{{title .Name}} = new(big.Int).SetBytes(log.Data)
	{{end}}
	{{end}}

	return event, nil
}
{{end}}

// EventSignatures maps event signatures to their hex representations
var EventSignatures = map[string]string{
{{range .Handlers}}
{{if eq .Kind "EthereumHandlerKind.Event"}}
	{{range .Topics}}
	"{{.}}": common.HexToHash(KeccakHash("{{.}}")).Hex(),
	{{end}}
{{end}}
{{end}}
}

// HandlerRegistry maps event signatures to their handlers
var HandlerRegistry = map[string]EventHandler{
{{range .Handlers}}
{{if eq .Kind "EthereumHandlerKind.Event"}}
	{{range .Topics}}
	EventSignatures["{{.}}"]: &{{$.Handler}}{},
	{{end}}
{{end}}
{{end}}
}

// KeccakHash returns the Keccak256 hash of a string
func KeccakHash(s string) string {
	return common.BytesToHash(crypto.Keccak256([]byte(s))).Hex()
}

// Event signatures
{{range .Events}}
var {{.Name}}EventSignature = crypto.Keccak256Hash([]byte("{{.Signature}}")).Hex()
{{end}}
`

func GenerateEventHandlers(config *CrawlerConfig, outputDir string) error {
	var handlers []EventHandlerConfig
	var events []struct {
		Name      string
		Signature string
		Params    []EventParam
	}

	for _, ds := range config.DataSources {
		for _, h := range ds.Mapping.Handlers {
			for _, topic := range h.Filter.Topics {
				name, params := parseEventSignature(topic)
				if name != "" {
					events = append(events, struct {
						Name      string
						Signature string
						Params    []EventParam
					}{
						Name:      name,
						Signature: topic,
						Params:    params,
					})
				}
			}
			handler := EventHandlerConfig{
				Kind:     h.Kind,
				Handler:  h.Handler,
				Function: h.Filter.Function,
				Topics:   h.Filter.Topics,
			}
			handlers = append(handlers, handler)
		}
	}

	data := struct {
		Handlers []EventHandlerConfig
		Events   []struct {
			Name      string
			Signature string
			Params    []EventParam
		}
		Handler string
	}{
		Handlers: handlers,
		Events:   events,
		Handler:  "DefaultHandler",
	}

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir+"/eventhandlers", 0755); err != nil {
		return err
	}

	// Create template functions
	funcMap := template.FuncMap{
		"add": func(a, b int) int {
			return a + b
		},
		"title": strings.Title,
		"getEventName": func(topics []string) string {
			if len(topics) == 0 {
				return ""
			}
			name, _ := parseEventSignature(topics[0])
			return name
		},
	}

	// Parse and execute the template
	tmpl, err := template.New("eventHandlers").Funcs(funcMap).Parse(eventHandlerTemplate)
	if err != nil {
		return err
	}

	f, err := os.Create(outputDir + "/eventhandlers/event_handlers.go")
	if err != nil {
		return err
	}
	defer f.Close()

	return tmpl.Execute(f, data)
}
