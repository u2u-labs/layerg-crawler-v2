
// Code generated - DO NOT EDIT.
// This file is generated by event_handler_generator.go

package eventhandlers

import (
	"context"
	"fmt"
	"math/big"

	"github.com/unicornultrafoundation/go-u2u/common"
	"github.com/unicornultrafoundation/go-u2u/core/types"
	"github.com/unicornultrafoundation/go-u2u/crypto"
	"go.uber.org/zap"
)

// EventHandler defines the interface for handling blockchain events
type EventHandler interface {
	HandleEvent(ctx context.Context, log *types.Log, logger *zap.SugaredLogger) error
}

// DefaultHandler is a basic implementation of EventHandler
type DefaultHandler struct{}

func (h *DefaultHandler) HandleEvent(ctx context.Context, log *types.Log, logger *zap.SugaredLogger) error {
	logger.Infow("Default handler called",
		"signature", log.Topics[0].Hex(),
		"contract", log.Address.Hex(),
		"tx", log.TxHash.Hex(),
	)
	return nil
}


// Transfer represents the event data for Transfer(address,address,uint256)
type Transfer struct {
	
	From common.Address // Capitalize field names
	
	To common.Address // Capitalize field names
	
	Value *big.Int // Capitalize field names
	
	Raw *types.Log
}

func UnpackTransfer(log *types.Log) (*Transfer, error) {
	event := new(Transfer)
	event.Raw = log

	
	
	if len(log.Topics) < 2 {
		return nil, fmt.Errorf("missing topic for indexed parameter from")
	}
	
	event.From = common.HexToAddress(log.Topics[1].Hex())
	
	
	
	
	if len(log.Topics) < 3 {
		return nil, fmt.Errorf("missing topic for indexed parameter to")
	}
	
	event.To = common.HexToAddress(log.Topics[2].Hex())
	
	
	
	
	event.Value = new(big.Int).SetBytes(log.Data)
	
	

	return event, nil
}

// Approval represents the event data for Approval(address,address,uint256)
type Approval struct {
	
	Owner common.Address // Capitalize field names
	
	Spender common.Address // Capitalize field names
	
	Value *big.Int // Capitalize field names
	
	Raw *types.Log
}

func UnpackApproval(log *types.Log) (*Approval, error) {
	event := new(Approval)
	event.Raw = log

	
	
	if len(log.Topics) < 2 {
		return nil, fmt.Errorf("missing topic for indexed parameter owner")
	}
	
	event.Owner = common.HexToAddress(log.Topics[1].Hex())
	
	
	
	
	if len(log.Topics) < 3 {
		return nil, fmt.Errorf("missing topic for indexed parameter spender")
	}
	
	event.Spender = common.HexToAddress(log.Topics[2].Hex())
	
	
	
	
	event.Value = new(big.Int).SetBytes(log.Data)
	
	

	return event, nil
}


// EventSignatures maps event signatures to their hex representations
var EventSignatures = map[string]string{




	
	"Transfer(address indexed from, address indexed to, uint256 amount)": common.HexToHash(KeccakHash("Transfer(address indexed from, address indexed to, uint256 amount)")).Hex(),
	



	
	"Approval(address owner, address spender, uint256 value)": common.HexToHash(KeccakHash("Approval(address owner, address spender, uint256 value)")).Hex(),
	


}

// HandlerRegistry maps event signatures to their handlers
var HandlerRegistry = map[string]EventHandler{




	
	EventSignatures["Transfer(address indexed from, address indexed to, uint256 amount)"]: &DefaultHandler{},
	



	
	EventSignatures["Approval(address owner, address spender, uint256 value)"]: &DefaultHandler{},
	


}

// KeccakHash returns the Keccak256 hash of a string
func KeccakHash(s string) string {
	return common.BytesToHash(crypto.Keccak256([]byte(s))).Hex()
}

// Event signatures

var TransferEventSignature = crypto.Keccak256Hash([]byte("Transfer(address,address,uint256)")).Hex()

var ApprovalEventSignature = crypto.Keccak256Hash([]byte("Approval(address,address,uint256)")).Hex()

