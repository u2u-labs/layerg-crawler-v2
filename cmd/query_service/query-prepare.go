package query_service

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/u2u-labs/layerg-crawler/cmd/core"

	"github.com/graphql-go/graphql/language/ast"
)

type FieldData struct {
	Name string
	Type string
}
type TypeData struct {
	TypeName string
	Fields   []FieldData
}
type FieldType struct {
	Name   string
	IsList bool
}
type GenerationData struct {
	Types   []TypeData
	HasDate bool
}

func GenerateQueryService(schemaPath string) error {
	schema, err := core.LoadSchema(schemaPath)
	if err != nil {
		log.Fatal(err)
	}
	var types []TypeData
	hasDate := false
	for tn, def := range schema.Types {
		if tn == "Query" || tn == "Mutation" {
			continue
		}
		td := TypeData{TypeName: tn}
		for _, f := range def.Fields {
			ft := resolveFieldType(f.Type)
			mapped := mapFieldType(ft)
			if mapped == "core.DateType" {
				hasDate = true
			}
			td.Fields = append(td.Fields, FieldData{
				Name: f.Name.Value,
				Type: mapped,
			})
		}
		types = append(types, td)
	}

	genData := GenerationData{
		Types:   types,
		HasDate: hasDate,
	}

	// Create a template with custom functions for singular and plural forms.
	tpl := template.New("gen").Funcs(template.FuncMap{
		"singular": func(s string) string {
			// If the name ends with an "s", remove it.
			if strings.HasSuffix(s, "s") {
				return s[:len(s)-1]
			}
			return s
		},
		"plural": func(s string) string {
			// If the name already ends with "s", return as is; otherwise append "s".
			if strings.HasSuffix(s, "s") {
				return s
			}
			return s + "s"
		},
	})
	tpl, err = tpl.Parse(tplSrc)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	if err = tpl.Execute(&buf, genData); err != nil {
		log.Fatal(err)
	}

	// Create directories if they don't exist
	queryDir := "generated/query"
	if err := os.MkdirAll(queryDir, 0755); err != nil {
		return fmt.Errorf("failed to create query directory: %w", err)
	}

	// Write the generated code
	outputPath := filepath.Join(queryDir, "generated.go")
	if err = ioutil.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write generated file: %w", err)
	}

	fmt.Println("Generated code in", outputPath)
	return nil
}

func resolveFieldType(t ast.Type) FieldType {
	switch tt := t.(type) {
	case *ast.List:
		ft := resolveFieldType(tt.Type)
		ft.IsList = true
		return ft
	case *ast.NonNull:
		return resolveFieldType(tt.Type)
	case *ast.Named:
		return FieldType{Name: tt.Name.Value, IsList: false}
	}
	return FieldType{}
}

func mapFieldType(ft FieldType) string {
	var base string
	switch ft.Name {
	case "ID":
		base = "graphql.ID"
	case "String":
		base = "graphql.String"
	case "Int":
		base = "graphql.Int"
	case "Float":
		base = "graphql.Float"
	case "Boolean":
		base = "graphql.Boolean"
	case "Date":
		base = "core.DateType" // Use your custom Date scalar (defined in core/scalars.go)
	case "BigInt":
		base = "core.BigIntType" // Use your custom Date scalar (defined in core/scalars.go)
	default:
		base = ft.Name + "Type"
	}
	if ft.IsList {
		return "graphql.NewList(" + base + ")"
	}
	return base
}

var tplSrc = `// Code generated by cmd/generate/main.go; DO NOT EDIT.
package generated

import (
	"github.com/graphql-go/graphql"
	"github.com/u2u-labs/layerg-crawler/cmd/core"
)

{{if .HasDate}}
var DateType = core.DateType
{{end}}

func CreateQueryFields(resolver *core.QueryResolver) graphql.Fields {
	// Pre-declare all types to handle forward references
	{{range .Types}}
	var {{.TypeName}}Type *graphql.Object
	{{end}}

	// Define all input types first since they don't have relationships
	{{range .Types}}
	{{.TypeName}}WhereInputType := graphql.NewInputObject(graphql.InputObjectConfig{
		Name: "{{.TypeName}}WhereInput",
		Fields: graphql.InputObjectConfigFieldMap{
			{{range .Fields}}"{{.Name}}": &graphql.InputObjectFieldConfig{Type: graphql.String},{{end}}
		},
	})
	{{end}}

	// Now define all object types with their relationships
	{{range .Types}}
	{{.TypeName}}Type = graphql.NewObject(graphql.ObjectConfig{
		Name: "{{.TypeName}}",
		Fields: graphql.FieldsThunk(func() graphql.Fields {
			return graphql.Fields{
				{{range .Fields}}
				"{{.Name}}": &graphql.Field{
					Type: {{if eq .Type "UserType"}}UserType{{else if eq .Type "PostType"}}PostType{{else if eq .Type "UserProfileType"}}UserProfileType{{else if eq .Type "graphql.NewList(PostType)"}}graphql.NewList(PostType){{else}}{{.Type}}{{end}},
				},
				{{end}}
			}
		}),
	})
	{{end}}

	return graphql.Fields{
		{{range .Types}}
		"{{singular .TypeName}}": &graphql.Field{
			Type: {{.TypeName}}Type,
			Args: graphql.FieldConfigArgument{
				"id": &graphql.ArgumentConfig{Type: graphql.NewNonNull(graphql.ID)},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return resolver.ResolveSingle("{{singular .TypeName}}", p)
			},
		},
		"{{plural .TypeName}}": &graphql.Field{
			Type: graphql.NewList({{.TypeName}}Type),
			Args: graphql.FieldConfigArgument{
				"page":  &graphql.ArgumentConfig{Type: graphql.Int},
				"limit": &graphql.ArgumentConfig{Type: graphql.Int},
				"order": &graphql.ArgumentConfig{Type: graphql.String},
				"where": &graphql.ArgumentConfig{Type: {{.TypeName}}WhereInputType},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return resolver.ResolveMultiple("{{singular .TypeName}}", p)
			},
		},
		{{end}}
	}
}`
