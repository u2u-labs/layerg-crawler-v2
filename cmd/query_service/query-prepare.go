package query_service

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/u2u-labs/layerg-crawler/cmd/core"

	"github.com/graphql-go/graphql/language/ast"
)

type FieldData struct {
	Name string
	Type string
}
type TypeData struct {
	TypeName string
	Fields   []FieldData
}
type FieldType struct {
	Name   string
	IsList bool
}
type GenerationData struct {
	Types   []TypeData
	HasDate bool
}

func GenerateQueryService(schemaPath string) error {
	schema, err := core.LoadSchema(schemaPath)
	if err != nil {
		log.Fatal(err)
	}
	var types []TypeData
	hasDate := false
	for tn, def := range schema.Types {
		if tn == "Query" || tn == "Mutation" {
			continue
		}
		td := TypeData{TypeName: tn}
		for _, f := range def.Fields {
			ft := resolveFieldType(f.Type)
			mapped := mapFieldType(ft)
			if mapped == "core.DateType" {
				hasDate = true
			}
			td.Fields = append(td.Fields, FieldData{
				Name: f.Name.Value,
				Type: mapped,
			})
		}
		types = append(types, td)
	}

	genData := GenerationData{
		Types:   types,
		HasDate: hasDate,
	}

	// Create a template with custom functions for singular, plural, and filter mapping.
	tpl := template.New("gen").Funcs(template.FuncMap{
		"singular": func(s string) string {
			if strings.HasSuffix(s, "s") {
				return s[:len(s)-1]
			}
			return s
		},
		"plural": func(s string) string {
			if strings.HasSuffix(s, "s") {
				return s
			}
			return s + "s"
		},
		"filter": mapFilterType,
	})
	tpl, err = tpl.Parse(tplSrc)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	if err = tpl.Execute(&buf, genData); err != nil {
		log.Fatal(err)
	}

	queryDir := "generated/query"
	if err := os.MkdirAll(queryDir, 0755); err != nil {
		return fmt.Errorf("failed to create query directory: %w", err)
	}

	outputPath := filepath.Join(queryDir, "generated.go")
	if err = ioutil.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write generated file: %w", err)
	}

	fmt.Println("Generated code in", outputPath)
	return nil
}

func resolveFieldType(t ast.Type) FieldType {
	switch tt := t.(type) {
	case *ast.List:
		ft := resolveFieldType(tt.Type)
		ft.IsList = true
		return ft
	case *ast.NonNull:
		return resolveFieldType(tt.Type)
	case *ast.Named:
		return FieldType{Name: tt.Name.Value, IsList: false}
	}
	return FieldType{}
}

func mapFieldType(ft FieldType) string {
	var base string
	switch ft.Name {
	case "ID":
		base = "graphql.ID"
	case "String":
		base = "graphql.String"
	case "Int":
		base = "graphql.Int"
	case "Float":
		base = "graphql.Float"
	case "Boolean":
		base = "graphql.Boolean"
	case "Date":
		base = "core.DateType" // Your custom Date scalar.
	case "BigInt":
		base = "core.BigIntType" // Your custom BigInt scalar.
	default:
		base = ft.Name + "Type"
	}
	if ft.IsList {
		return "graphql.NewList(" + base + ")"
	}
	return base
}

func mapFilterType(fieldType string) string {
	// Map the field type to the corresponding filter type.
	switch fieldType {
	case "graphql.ID":
		return "IDFilterType"
	case "graphql.String":
		return "StringFilterType"
	case "core.BigIntType":
		return "BigIntFilterType"
	default:
		// Default fallback. (You can extend this mapping as needed.)
		return "StringFilterType"
	}
}

var tplSrc = `// Code generated by cmd/generate/query-prepare.go; DO NOT EDIT.
package generated

import (
	"github.com/graphql-go/graphql"
	"github.com/u2u-labs/layerg-crawler/cmd/core"
)

{{if .HasDate}}
var DateType = core.DateType
{{end}}

var StringFilterType = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "StringFilter",
	Fields: graphql.InputObjectConfigFieldMap{
		"gte": &graphql.InputObjectFieldConfig{Type: graphql.String},
		"gt":  &graphql.InputObjectFieldConfig{Type: graphql.String},
		"eq":  &graphql.InputObjectFieldConfig{Type: graphql.String},
		"lt":  &graphql.InputObjectFieldConfig{Type: graphql.String},
		"lte": &graphql.InputObjectFieldConfig{Type: graphql.String},
	},
})
var BigIntFilterType = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "BigIntFilter",
	Fields: graphql.InputObjectConfigFieldMap{
		"gte": &graphql.InputObjectFieldConfig{Type: core.BigIntType},
		"gt":  &graphql.InputObjectFieldConfig{Type: core.BigIntType},
		"eq":  &graphql.InputObjectFieldConfig{Type: core.BigIntType},
		"lt":  &graphql.InputObjectFieldConfig{Type: core.BigIntType},
		"lte": &graphql.InputObjectFieldConfig{Type: core.BigIntType},
	},
})
var IDFilterType = graphql.NewInputObject(graphql.InputObjectConfig{
	Name: "IDFilter",
	Fields: graphql.InputObjectConfigFieldMap{
		"gte": &graphql.InputObjectFieldConfig{Type: graphql.ID},
		"gt":  &graphql.InputObjectFieldConfig{Type: graphql.ID},
		"eq":  &graphql.InputObjectFieldConfig{Type: graphql.ID},
		"lt":  &graphql.InputObjectFieldConfig{Type: graphql.ID},
		"lte": &graphql.InputObjectFieldConfig{Type: graphql.ID},
	},
})

func CreateQueryFields(resolver *core.QueryResolver) graphql.Fields {
	// Pre-declare all types to handle forward references
	{{range .Types}}
	var {{.TypeName}}Type *graphql.Object
	{{end}}

	// Define all input types first since they don't have relationships
	{{range .Types}}
	var {{.TypeName}}WhereInputFields = graphql.InputObjectConfigFieldMap{
		{{range .Fields}}"{{.Name}}": &graphql.InputObjectFieldConfig{Type: {{filter .Type}}},
		{{end}}
		"AND": &graphql.InputObjectFieldConfig{},
		"OR":  &graphql.InputObjectFieldConfig{},
	}
	var {{.TypeName}}WhereInputType = graphql.NewInputObject(graphql.InputObjectConfig{
		Name:   "{{.TypeName}}WhereInput",
		Fields: {{.TypeName}}WhereInputFields,
	})
	{{.TypeName}}WhereInputFields["AND"].Type = graphql.NewList({{.TypeName}}WhereInputType)
	{{.TypeName}}WhereInputFields["OR"].Type = graphql.NewList({{.TypeName}}WhereInputType)
	{{end}}

	// Now define all object types with their relationships
	{{range .Types}}
	{{.TypeName}}Type = graphql.NewObject(graphql.ObjectConfig{
		Name: "{{.TypeName}}",
		Fields: graphql.FieldsThunk(func() graphql.Fields {
			return graphql.Fields{
				{{range .Fields}}
				"{{.Name}}": &graphql.Field{
					Type: {{.Type}},
				},
				{{end}}
			}
		}),
	})
	{{end}}

	return graphql.Fields{
		{{range .Types}}
		"{{singular .TypeName}}": &graphql.Field{
			Type: {{.TypeName}}Type,
			Args: graphql.FieldConfigArgument{
				"id": &graphql.ArgumentConfig{Type: graphql.NewNonNull(graphql.ID)},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return resolver.ResolveSingle("{{singular .TypeName}}", p)
			},
		},
		"{{plural .TypeName}}": &graphql.Field{
			Type: graphql.NewList({{.TypeName}}Type),
			Args: graphql.FieldConfigArgument{
				"page":  &graphql.ArgumentConfig{Type: graphql.Int},
				"limit": &graphql.ArgumentConfig{Type: graphql.Int},
				"order": &graphql.ArgumentConfig{Type: graphql.String},
				"where": &graphql.ArgumentConfig{Type: {{.TypeName}}WhereInputType},
			},
			Resolve: func(p graphql.ResolveParams) (interface{}, error) {
				return resolver.ResolveMultiple("{{singular .TypeName}}", p)
			},
		},
		{{end}}
	}
}
`
